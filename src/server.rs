use crate::index::IndexManager;
use crate::persistence::Text;
use crate::text_splitters::TextSplitterKind;
use crate::{
    CreateIndexParams, EmbeddingRouter, MemorySessionRouter, MemoryStoragePolicy, MetricKind,
    ServerConfig,
};

use anyhow::Result;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use axum::{extract::State, routing::get, routing::post, Json, Router};
use pyo3::Python;
use tokio::signal;
use tracing::info;

use serde::{Deserialize, Serialize};
use smart_default::SmartDefault;
use std::collections::HashMap;
use uuid::Uuid;

use std::net::SocketAddr;
use std::str::FromStr;
use std::sync::Arc;

/// Request payload for generating text embeddings.
#[derive(Debug, Serialize, Deserialize)]
struct GenerateEmbeddingRequest {
    /// Input texts for which embeddings will be generated.
    inputs: Vec<String>,
    /// Name of the model to use for generating embeddings.
    model: String,
}

/// Response payload for generating text embeddings.
#[derive(Debug, Serialize, Deserialize)]
struct GenerateEmbeddingResponse {
    embeddings: Option<Vec<Vec<f32>>>,
}

/// An embedding model and its properties.
#[derive(Debug, Serialize, Deserialize)]
struct EmbeddingModel {
    /// Name of the embedding model.
    name: String,
    /// Number of dimensions in the embeddings generated by this model.
    dimensions: u64,
}

/// Response payload for listing available embedding models.
#[derive(Debug, Serialize, Deserialize)]
struct ListEmbeddingModelsResponse {
    /// List of available embedding models.
    models: Vec<EmbeddingModel>,
}

#[derive(SmartDefault, Debug, Serialize, Deserialize, strum::Display)]
#[strum(serialize_all = "snake_case")]
enum ApiTextSplitterKind {
    // Do not split text.
    #[serde(rename = "none")]
    None,

    /// Split text by new lines.
    #[default]
    #[serde(rename = "new_line")]
    NewLine,

    /// Split a document across the regex boundary
    #[serde(rename = "regex")]
    Regex { pattern: String },
}

#[derive(SmartDefault, Debug, Serialize, Deserialize)]
enum MemoryPolicyKind {
    // Use Indefinite policy
    #[default]
    #[serde(rename = "indefinite")]
    Indefinite,

    // Use Windows
    #[serde(rename = "window")]
    Window,

    // Use LRU
    #[serde(rename = "lru")]
    Lru,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename = "metric")]
enum IndexMetric {
    #[serde(rename = "dot")]
    Dot,

    #[serde(rename = "cosine")]
    Cosine,

    #[serde(rename = "euclidean")]
    Euclidean,
}

/// Request payload for creating a new vector index.
#[derive(Debug, Serialize, Deserialize)]
struct IndexCreateRequest {
    /// Name of the new vector index.
    name: String,
    /// Name of the embedding model to use for indexing.
    embedding_model: String,
    /// Number of dimensions in the embeddings generated by the embedding model.
    metric: IndexMetric,
    /// The text splitter to use for splitting text into fragments.
    text_splitter: ApiTextSplitterKind,

    /// Hash on these paramters
    hash_on: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
struct IndexCreateResponse {}

#[derive(Debug, Serialize, Deserialize)]
pub struct Document {
    pub text: String,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct AddTextsRequest {
    index: String,
    documents: Vec<Document>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
struct IndexAdditionResponse {
    sequence: u64,
    errors: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct SearchRequest {
    index: String,
    query: String,
    k: u64,
}

#[derive(Debug, Serialize, Deserialize)]
struct CreateMemorySessionRequest {
    session_id: Option<Uuid>,
    /// The memory policy for storing and retrieving from memory
    memory_storage_policy: MemoryStoragePolicy,
}

#[derive(Serialize, Deserialize)]
struct CreateMemorySessionResponse {
    session_id: Option<Uuid>,
}

#[derive(Debug, Serialize, Deserialize)]
struct MemorySessionAddRequest {
    session_id: Uuid,
    turn: String,
}

#[derive(Serialize, Deserialize)]
struct MemorySessionAddResponse {}

#[derive(Debug, Serialize, Deserialize)]
struct MemorySessionRetrieveRequest {
    session_id: Uuid,
    query: String,
}

#[derive(Serialize, Deserialize)]
struct MemorySessionRetrieveResponse {
    history: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
struct DocumentFragment {
    text: String,
    metadata: serde_json::Value,
}

#[derive(Debug, Serialize, Deserialize, Default)]
struct IndexSearchResponse {
    results: Vec<DocumentFragment>,
}

pub struct IndexifyAPIError {
    status_code: StatusCode,
    message: String,
}

impl IndexifyAPIError {
    fn new(status_code: StatusCode, message: String) -> Self {
        Self {
            status_code,
            message,
        }
    }
}

impl IntoResponse for IndexifyAPIError {
    fn into_response(self) -> Response {
        (self.status_code, self.message).into_response()
    }
}

type IndexEndpointState = (Arc<Option<IndexManager>>, Arc<EmbeddingRouter>);

pub struct Server {
    addr: SocketAddr,
    config: Arc<ServerConfig>,
}
impl Server {
    pub fn new(config: Arc<super::server_config::ServerConfig>) -> Result<Self> {
        let addr: SocketAddr = config.listen_addr.parse()?;
        Ok(Self { addr, config })
    }

    pub async fn run(&self) -> Result<()> {
        let embedding_router = Arc::new(EmbeddingRouter::new(self.config.clone())?);
        let memory_session_router: Arc<MemorySessionRouter> =
            Arc::new(MemorySessionRouter::new(self.config.clone())?);
        let index_manager = Arc::new(
            IndexManager::new(self.config.index_config.clone(), embedding_router.clone()).await?,
        );
        let app = Router::new()
            .route("/", get(root))
            .route(
                "/embeddings/models",
                get(list_embedding_models).with_state(embedding_router.clone()),
            )
            .route(
                "/embeddings/generate",
                get(generate_embedding).with_state(embedding_router.clone()),
            )
            .route(
                "/index/create",
                post(index_create).with_state((index_manager.clone(), embedding_router.clone())),
            )
            .route(
                "/index/add",
                post(add_texts).with_state((index_manager.clone(), embedding_router.clone())),
            )
            .route(
                "/index/search",
                get(index_search).with_state((index_manager.clone(), embedding_router.clone())),
            )
            .route(
                "/memory/create",
                get(create_memory_session).with_state(memory_session_router.clone()),
            )
            .route(
                "/memory/add",
                get(add_record).with_state(memory_session_router.clone()),
            )
            .route(
                "/memory/retrieve",
                get(retrieve_records).with_state(memory_session_router.clone()),
            );
        info!("server is listening at addr {:?}", &self.addr.to_string());
        axum::Server::bind(&self.addr)
            .serve(app.into_make_service())
            .with_graceful_shutdown(shutdown_signal())
            .await?;
        Ok(())
    }
}

async fn root() -> &'static str {
    "Indexify Server"
}

#[axum_macros::debug_handler]
async fn index_create(
    State(index_args): State<IndexEndpointState>,
    Json(payload): Json<IndexCreateRequest>,
) -> Result<Json<IndexCreateResponse>, IndexifyAPIError> {
    if index_args.0.is_none() {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            "server is not configured to have indexes".into(),
        ));
    }
    let try_model = index_args.1.get_model(payload.embedding_model.clone());
    if let Err(err) = try_model {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            err.to_string(),
        ));
    }
    let dim = try_model.unwrap().dimensions();
    let index_params = CreateIndexParams {
        name: payload.name.clone(),
        vector_dim: dim,
        metric: match payload.metric {
            IndexMetric::Cosine => MetricKind::Cosine,
            IndexMetric::Dot => MetricKind::Dot,
            IndexMetric::Euclidean => MetricKind::Euclidean,
        },
        unique_params: payload.hash_on,
    };
    let index_manager = index_args.0.as_ref();
    let splitter_kind = TextSplitterKind::from_str(&payload.text_splitter.to_string()).unwrap();
    let result = index_manager
        .as_ref()
        .unwrap()
        .create_index(index_params, payload.embedding_model, splitter_kind)
        .await;
    if let Err(err) = result {
        return Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ));
    }
    Ok(Json(IndexCreateResponse {}))
}

#[axum_macros::debug_handler]
async fn add_texts(
    State(index_args): State<IndexEndpointState>,
    Json(payload): Json<AddTextsRequest>,
) -> Result<Json<IndexAdditionResponse>, IndexifyAPIError> {
    if index_args.0.is_none() {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            "server is not configured to have indexes".into(),
        ));
    }
    let index_manager = index_args.0.as_ref().as_ref().unwrap();
    let try_index = index_manager.load(payload.index).await;
    if let Err(err) = try_index {
        return Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ));
    }
    if try_index.as_ref().unwrap().is_none() {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            "index does not exist".into(),
        ));
    }
    let index = try_index.unwrap().unwrap();
    let texts = payload
        .documents
        .iter()
        .map(|d| Text {
            text: d.text.to_owned(),
            metadata: d.metadata.to_owned(),
        })
        .collect();
    let result = index.add_texts(texts).await;
    if let Err(err) = result {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            err.to_string(),
        ));
    }

    Ok(Json(IndexAdditionResponse::default()))
}

#[axum_macros::debug_handler]
async fn create_memory_session(
    State(memory_manager): State<Arc<MemorySessionRouter>>,
    Json(payload): Json<CreateMemorySessionRequest>,
) -> Result<Json<CreateMemorySessionResponse>, IndexifyAPIError> {
    let result = memory_manager.create_session(payload.session_id, payload.memory_storage_policy);

    if let Err(err) = result {
        return Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ));
    }
    Ok(Json(CreateMemorySessionResponse {
        session_id: Some(result.unwrap()),
    }))
}

#[axum_macros::debug_handler]
async fn add_record(
    State(memory_manager): State<Arc<MemorySessionRouter>>,
    Json(payload): Json<MemorySessionAddRequest>,
) -> Result<Json<MemorySessionAddResponse>, IndexifyAPIError> {
    let result = memory_manager.add_turn(payload.session_id, payload.turn);

    if let Err(err) = result {
        Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ))
    } else {
        Ok(Json(MemorySessionAddResponse {}))
    }
}

#[axum_macros::debug_handler]
async fn retrieve_records(
    State(memory_manager): State<Arc<MemorySessionRouter>>,
    Json(payload): Json<MemorySessionRetrieveRequest>,
) -> Result<Json<MemorySessionRetrieveResponse>, IndexifyAPIError> {
    let result = memory_manager.retrieve_history(payload.session_id, payload.query);

    if let Err(err) = result {
        Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ))
    } else {
        Ok(Json(MemorySessionRetrieveResponse {
            history: result.unwrap(),
        }))
    }
}

#[axum_macros::debug_handler]
async fn index_search(
    State(index_args): State<IndexEndpointState>,
    Json(query): Json<SearchRequest>,
) -> Result<Json<IndexSearchResponse>, IndexifyAPIError> {
    if index_args.0.is_none() {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            "server is not configured to have indexes".into(),
        ));
    }

    let index_manager = index_args.0.as_ref().as_ref().unwrap();
    let try_index = index_manager.load(query.index.clone()).await;
    if let Err(err) = try_index {
        return Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ));
    }
    if try_index.as_ref().unwrap().is_none() {
        return Err(IndexifyAPIError::new(
            StatusCode::BAD_REQUEST,
            "index does not exist".into(),
        ));
    }
    let index = try_index.unwrap().unwrap();
    let results = index.search(query.query, query.k).await;
    if let Err(err) = results {
        return Err(IndexifyAPIError::new(
            StatusCode::INTERNAL_SERVER_ERROR,
            err.to_string(),
        ));
    }
    let document_fragments: Vec<DocumentFragment> = results
        .unwrap()
        .iter()
        .map(|text| DocumentFragment {
            text: text.texts.to_owned(),
            metadata: text.metadata.to_owned(),
        })
        .collect();
    Ok(Json(IndexSearchResponse {
        results: document_fragments,
    }))
}

#[axum_macros::debug_handler]
async fn list_embedding_models(
    State(embedding_router): State<Arc<EmbeddingRouter>>,
) -> Json<ListEmbeddingModelsResponse> {
    let model_names = embedding_router.list_models();
    let mut models: Vec<EmbeddingModel> = Vec::new();
    for model_name in model_names {
        let model = embedding_router.get_model(model_name.clone()).unwrap();
        models.push(EmbeddingModel {
            name: model_name.clone(),
            dimensions: model.dimensions(),
        })
    }
    Json(ListEmbeddingModelsResponse { models })
}

#[axum_macros::debug_handler]
async fn generate_embedding(
    State(embedding_router): State<Arc<EmbeddingRouter>>,
    Json(payload): Json<GenerateEmbeddingRequest>,
) -> Result<Json<GenerateEmbeddingResponse>, IndexifyAPIError> {
    let try_embedding_generator = embedding_router.get_model(payload.model);
    if let Err(err) = &try_embedding_generator {
        return Err(IndexifyAPIError::new(
            StatusCode::NOT_ACCEPTABLE,
            err.to_string(),
        ));
    }
    let embeddings = try_embedding_generator
        .unwrap()
        .generate_embeddings(payload.inputs)
        .await;

    if let Err(err) = embeddings {
        return Err(IndexifyAPIError::new(
            StatusCode::EXPECTATION_FAILED,
            err.to_string(),
        ));
    }

    Ok(Json(GenerateEmbeddingResponse {
        embeddings: Some(embeddings.unwrap()),
    }))
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            let _ = Python::with_gil(|py| py.check_signals());
        },
        _ = terminate => {
            let _ = Python::with_gil(|py| py.check_signals());
        },
    }
    info!("signal received, shutting down server gracefully");
}
